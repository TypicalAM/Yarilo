// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "service.proto" (package "proto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * AP.proto
 *
 * @generated from protobuf message proto.RadioInfo
 */
export interface RadioInfo {
    /**
     * @generated from protobuf field: int32 rssi = 8;
     */
    rssi: number; // Received signal strength indicator
    /**
     * @generated from protobuf field: int32 noise = 9;
     */
    noise: number; // Signal noise
    /**
     * @generated from protobuf field: int32 snr = 10;
     */
    snr: number; // Signal to noise ratio, used to determine connection
}
/**
 * @generated from protobuf message proto.ClientWindow
 */
export interface ClientWindow {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
    /**
     * @generated from protobuf field: bool ended = 3;
     */
    ended: boolean;
    /**
     * @generated from protobuf field: bool decrypted = 4;
     */
    decrypted: boolean;
    /**
     * @generated from protobuf field: uint32 packet_count = 5;
     */
    packetCount: number;
    /**
     * @generated from protobuf field: uint32 auth_packet_count = 6;
     */
    authPacketCount: number; // Handshake count
    /**
     * @generated from protobuf field: string ptk = 7;
     */
    ptk: string; // Pairwise Transient key, available if decrypted
}
/**
 * @generated from protobuf message proto.ClientInfo
 */
export interface ClientInfo {
    /**
     * @generated from protobuf field: string hwaddr = 1;
     */
    hwaddr: string; // MAC
    /**
     * @generated from protobuf field: string hostname = 2;
     */
    hostname: string; // Friendly hostname (via DHCP)
    /**
     * @generated from protobuf field: string ipv4 = 3;
     */
    ipv4: string;
    /**
     * @generated from protobuf field: string ipv6 = 4;
     */
    ipv6: string;
    /**
     * @generated from protobuf field: uint32 sent_unicast = 5;
     */
    sentUnicast: number;
    /**
     * @generated from protobuf field: uint32 sent_total = 6;
     */
    sentTotal: number;
    /**
     * @generated from protobuf field: uint32 received = 7;
     */
    received: number;
    /**
     * @generated from protobuf field: proto.RadioInfo radio_info = 8;
     */
    radioInfo?: RadioInfo; // If this is not empty, this client is wireless
    /**
     * @generated from protobuf field: bool pmf_active = 9;
     */
    pmfActive: boolean;
    /**
     * @generated from protobuf field: bool router = 10;
     */
    router: boolean;
    /**
     * @generated from protobuf field: uint32 current_eapol_pkt_count = 11;
     */
    currentEapolPktCount: number;
    /**
     * @generated from protobuf field: repeated proto.ClientWindow windows = 12;
     */
    windows: ClientWindow[];
    /**
     * @generated from protobuf field: string device_vendor = 13;
     */
    deviceVendor: string;
}
/**
 * @generated from protobuf message proto.GroupWindow
 */
export interface GroupWindow {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start = 1;
     */
    start?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end = 2;
     */
    end?: Timestamp;
    /**
     * @generated from protobuf field: bool ended = 3;
     */
    ended: boolean;
    /**
     * @generated from protobuf field: bool decrypted = 4;
     */
    decrypted: boolean;
    /**
     * @generated from protobuf field: uint32 packet_count = 5;
     */
    packetCount: number;
    /**
     * @generated from protobuf field: uint32 auth_packet_count = 6;
     */
    authPacketCount: number;
    /**
     * @generated from protobuf field: string gtk = 7;
     */
    gtk: string; // Group Temporal Key, available if decrypted
}
/**
 * @generated from protobuf message proto.WiFiStandardInfo
 */
export interface WiFiStandardInfo {
    /**
     * @generated from protobuf field: proto.WiFiStandard std = 1;
     */
    std: WiFiStandard;
    /**
     * @generated from protobuf field: bool single_beamformer_support = 2;
     */
    singleBeamformerSupport: boolean;
    /**
     * @generated from protobuf field: bool single_beamformee_support = 3;
     */
    singleBeamformeeSupport: boolean;
    /**
     * @generated from protobuf field: bool multi_beamformer_support = 4;
     */
    multiBeamformerSupport: boolean;
    /**
     * @generated from protobuf field: bool multi_beamformee_support = 5;
     */
    multiBeamformeeSupport: boolean;
    /**
     * @generated from protobuf field: repeated uint32 mcs_supported_idx = 6;
     */
    mcsSupportedIdx: number[];
    /**
     * @generated from protobuf field: repeated proto.Modulation modulation_supported = 7;
     */
    modulationSupported: Modulation[];
    /**
     * @generated from protobuf field: repeated uint32 spatial_streams_supported = 8;
     */
    spatialStreamsSupported: number[];
    /**
     * @generated from protobuf field: repeated proto.ChannelWidth channel_widths_supported = 9;
     */
    channelWidthsSupported: ChannelWidth[];
}
/**
 * @generated from protobuf message proto.MulticastGroup
 */
export interface MulticastGroup {
    /**
     * @generated from protobuf field: string addr = 1;
     */
    addr: string;
    /**
     * @generated from protobuf field: uint32 count = 2;
     */
    count: number;
}
/**
 * @generated from protobuf message proto.ChannelInfo
 */
export interface ChannelInfo {
    /**
     * @generated from protobuf field: uint32 control_frequency = 1;
     */
    controlFrequency: number;
    /**
     * @generated from protobuf field: uint32 channel = 2;
     */
    channel: number;
    /**
     * @generated from protobuf field: proto.ChannelType type = 3;
     */
    type: ChannelType;
}
/**
 * @generated from protobuf message proto.AccessPointInfo
 */
export interface AccessPointInfo {
    /**
     * @generated from protobuf field: string ssid = 1;
     */
    ssid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
    /**
     * @generated from protobuf field: uint32 encrypted_packet_count = 3;
     */
    encryptedPacketCount: number;
    /**
     * @generated from protobuf field: uint32 decrypted_packet_count = 4;
     */
    decryptedPacketCount: number;
    /**
     * @generated from protobuf field: proto.RadioInfo radio_info = 5;
     */
    radioInfo?: RadioInfo;
    /**
     * @generated from protobuf field: bool pmf_capable = 6;
     */
    pmfCapable: boolean; // Protected management frames - 802.11w
    /**
     * @generated from protobuf field: bool pmf_required = 7;
     */
    pmfRequired: boolean;
    /**
     * @generated from protobuf field: repeated proto.ChannelInfo supported_chanels = 8;
     */
    supportedChanels: ChannelInfo[];
    /**
     * @generated from protobuf field: repeated proto.WiFiStandardInfo supported_standards = 9;
     */
    supportedStandards: WiFiStandardInfo[];
    /**
     * @generated from protobuf field: repeated proto.MulticastGroup multicast_groups = 10;
     */
    multicastGroups: MulticastGroup[];
    /**
     * @generated from protobuf field: repeated proto.NetworkSecurity security = 11;
     */
    security: NetworkSecurity[]; // A network can support multiple security standards at once
    /**
     * @generated from protobuf field: repeated proto.ClientInfo clients = 12;
     */
    clients: ClientInfo[];
    /**
     * @generated from protobuf field: repeated proto.GroupWindow group_windows = 13;
     */
    groupWindows: GroupWindow[];
    /**
     * @generated from protobuf field: string device_vendor = 14;
     */
    deviceVendor: string;
}
/**
 * @generated from protobuf message proto.Raw
 */
export interface Raw {
    /**
     * @generated from protobuf field: bytes payload = 1;
     */
    payload: Uint8Array;
}
/**
 * @generated from protobuf message proto.ARP
 */
export interface ARP {
    /**
     * @generated from protobuf field: string sender_ip_address = 1;
     */
    senderIpAddress: string;
    /**
     * @generated from protobuf field: string sender_mac_address = 2;
     */
    senderMacAddress: string;
    /**
     * @generated from protobuf field: string target_ip_address = 3;
     */
    targetIpAddress: string;
    /**
     * @generated from protobuf field: string target_mac_address = 4;
     */
    targetMacAddress: string;
}
/**
 * @generated from protobuf message proto.ICMP
 */
export interface ICMP {
    /**
     * @generated from protobuf field: proto.ICMP.Type type = 1;
     */
    type: ICMP_Type;
    /**
     * @generated from protobuf field: uint32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf enum proto.ICMP.Type
 */
export enum ICMP_Type {
    /**
     * @generated from protobuf enum value: ECHO_REPLY = 0;
     */
    ECHO_REPLY = 0,
    /**
     * @generated from protobuf enum value: DESTINATION_UNREACHABLE = 3;
     */
    DESTINATION_UNREACHABLE = 3,
    /**
     * @generated from protobuf enum value: ECHO_REQUEST = 8;
     */
    ECHO_REQUEST = 8,
    /**
     * @generated from protobuf enum value: TIME_EXCEEDED = 11;
     */
    TIME_EXCEEDED = 11,
    /**
     * @generated from protobuf enum value: OTHER = 12;
     */
    OTHER = 12
}
/**
 * @generated from protobuf message proto.ICMPv6
 */
export interface ICMPv6 {
    /**
     * @generated from protobuf field: proto.ICMPv6.Type type = 1;
     */
    type: ICMPv6_Type;
    /**
     * @generated from protobuf field: uint32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: uint32 checksum = 3;
     */
    checksum: number;
}
/**
 * @generated from protobuf enum proto.ICMPv6.Type
 */
export enum ICMPv6_Type {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ECHO_REQUEST = 128;
     */
    ECHO_REQUEST = 128,
    /**
     * @generated from protobuf enum value: ECHO_REPLY = 129;
     */
    ECHO_REPLY = 129,
    /**
     * @generated from protobuf enum value: DESTINATION_UNREACHABLE = 1;
     */
    DESTINATION_UNREACHABLE = 1,
    /**
     * @generated from protobuf enum value: PACKET_TOO_BIG = 2;
     */
    PACKET_TOO_BIG = 2,
    /**
     * @generated from protobuf enum value: TIME_EXCEEDED = 3;
     */
    TIME_EXCEEDED = 3,
    /**
     * @generated from protobuf enum value: PARAMETER_PROBLEM = 4;
     */
    PARAMETER_PROBLEM = 4,
    /**
     * @generated from protobuf enum value: NEIGHBOR_SOLICITATION = 135;
     */
    NEIGHBOR_SOLICITATION = 135,
    /**
     * @generated from protobuf enum value: NEIGHBOR_ADVERTISEMENT = 136;
     */
    NEIGHBOR_ADVERTISEMENT = 136
}
/**
 * @generated from protobuf message proto.DNS
 */
export interface DNS {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: bool qr = 2;
     */
    qr: boolean; // Query/Response
    /**
     * @generated from protobuf field: repeated proto.DNS.Question questions = 3;
     */
    questions: DNS_Question[];
    /**
     * @generated from protobuf field: repeated proto.DNS.ResourceRecord answers = 4;
     */
    answers: DNS_ResourceRecord[];
}
/**
 * @generated from protobuf message proto.DNS.Question
 */
export interface DNS_Question {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number;
}
/**
 * @generated from protobuf message proto.DNS.ResourceRecord
 */
export interface DNS_ResourceRecord {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message proto.DHCP
 */
export interface DHCP {
    /**
     * @generated from protobuf field: uint32 message_type = 1;
     */
    messageType: number;
    /**
     * @generated from protobuf field: uint32 transaction_id = 2;
     */
    transactionId: number;
    /**
     * @generated from protobuf field: string client_ip_address = 3;
     */
    clientIpAddress: string;
    /**
     * @generated from protobuf field: string your_ip_address = 4;
     */
    yourIpAddress: string;
    /**
     * @generated from protobuf field: string server_ip_address = 5;
     */
    serverIpAddress: string;
    /**
     * @generated from protobuf field: string client_mac_address = 6;
     */
    clientMacAddress: string;
}
/**
 * @generated from protobuf message proto.DHCPv6
 */
export interface DHCPv6 {
    /**
     * @generated from protobuf field: uint32 message_type = 1;
     */
    messageType: number;
    /**
     * @generated from protobuf field: uint32 transaction_id = 2;
     */
    transactionId: number;
    /**
     * @generated from protobuf field: repeated proto.DHCPv6.Option options = 3;
     */
    options: DHCPv6_Option[];
}
/**
 * @generated from protobuf message proto.DHCPv6.Option
 */
export interface DHCPv6_Option {
    /**
     * @generated from protobuf field: uint32 option_code = 1;
     */
    optionCode: number; // Option code indicating the type of option
    /**
     * @generated from protobuf field: uint32 option_length = 2;
     */
    optionLength: number; // Length of the option data
    /**
     * @generated from protobuf field: bytes option_data = 3;
     */
    optionData: Uint8Array; // Option-specific data
}
/**
 * @generated from protobuf message proto.IP
 */
export interface IP {
    /**
     * @generated from protobuf field: string source_address = 1;
     */
    sourceAddress: string;
    /**
     * @generated from protobuf field: string destination_address = 2;
     */
    destinationAddress: string;
    /**
     * @generated from protobuf field: uint32 ttl = 3;
     */
    ttl: number;
    /**
     * @generated from protobuf field: uint32 protocol = 4;
     */
    protocol: number;
    /**
     * @generated from protobuf field: uint32 total_length = 5;
     */
    totalLength: number;
    /**
     * @generated from protobuf field: bytes payload = 6;
     */
    payload: Uint8Array;
    /**
     * @generated from protobuf field: proto.Protocol next_protocol = 7;
     */
    nextProtocol: Protocol; // Next protocol
    /**
     * @generated from protobuf oneof: next
     */
    next: {
        oneofKind: "icmp";
        /**
         * @generated from protobuf field: proto.ICMP icmp = 8;
         */
        icmp: ICMP;
    } | {
        oneofKind: "tcp";
        /**
         * @generated from protobuf field: proto.TCP tcp = 9;
         */
        tcp: TCP;
    } | {
        oneofKind: "udp";
        /**
         * @generated from protobuf field: proto.UDP udp = 10;
         */
        udp: UDP;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message proto.IPv6
 */
export interface IPv6 {
    /**
     * @generated from protobuf field: string source_address = 1;
     */
    sourceAddress: string;
    /**
     * @generated from protobuf field: string destination_address = 2;
     */
    destinationAddress: string;
    /**
     * @generated from protobuf field: uint32 hop_limit = 3;
     */
    hopLimit: number;
    /**
     * @generated from protobuf field: uint32 next_header = 4;
     */
    nextHeader: number;
    /**
     * @generated from protobuf field: uint32 payload_length = 5;
     */
    payloadLength: number;
    /**
     * @generated from protobuf field: bytes payload = 6;
     */
    payload: Uint8Array;
    /**
     * @generated from protobuf field: proto.Protocol next_protocol = 7;
     */
    nextProtocol: Protocol; // Next protocol
    /**
     * @generated from protobuf oneof: next
     */
    next: {
        oneofKind: "icmpv6";
        /**
         * @generated from protobuf field: proto.ICMPv6 icmpv6 = 8;
         */
        icmpv6: ICMPv6;
    } | {
        oneofKind: "tcp";
        /**
         * @generated from protobuf field: proto.TCP tcp = 9;
         */
        tcp: TCP;
    } | {
        oneofKind: "udp";
        /**
         * @generated from protobuf field: proto.UDP udp = 10;
         */
        udp: UDP;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message proto.TCP
 */
export interface TCP {
    /**
     * @generated from protobuf field: uint32 source_port = 1;
     */
    sourcePort: number;
    /**
     * @generated from protobuf field: uint32 destination_port = 2;
     */
    destinationPort: number;
    /**
     * @generated from protobuf field: uint32 sequence_number = 3;
     */
    sequenceNumber: number;
    /**
     * @generated from protobuf field: uint32 acknowledgment_number = 4;
     */
    acknowledgmentNumber: number;
    /**
     * @generated from protobuf field: uint32 window_size = 5;
     */
    windowSize: number;
    /**
     * @generated from protobuf field: bool syn = 6;
     */
    syn: boolean;
    /**
     * @generated from protobuf field: bool ack = 7;
     */
    ack: boolean;
    /**
     * @generated from protobuf field: bool fin = 8;
     */
    fin: boolean;
}
/**
 * @generated from protobuf message proto.UDP
 */
export interface UDP {
    /**
     * @generated from protobuf field: uint32 source_port = 1;
     */
    sourcePort: number;
    /**
     * @generated from protobuf field: uint32 destination_port = 2;
     */
    destinationPort: number;
    /**
     * @generated from protobuf field: proto.Protocol next_protocol = 4;
     */
    nextProtocol: Protocol;
    /**
     * @generated from protobuf oneof: next
     */
    next: {
        oneofKind: "dns";
        /**
         * @generated from protobuf field: proto.DNS dns = 5;
         */
        dns: DNS;
    } | {
        oneofKind: "dhcp";
        /**
         * @generated from protobuf field: proto.DHCP dhcp = 6;
         */
        dhcp: DHCP;
    } | {
        oneofKind: "dhcpv6";
        /**
         * @generated from protobuf field: proto.DHCPv6 dhcpv6 = 7;
         */
        dhcpv6: DHCPv6;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message proto.Packet
 */
export interface Packet {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp capture_time = 1;
     */
    captureTime?: Timestamp;
    /**
     * @generated from protobuf field: string src = 2;
     */
    src: string; // MAC address of the sender
    /**
     * @generated from protobuf field: string dst = 3;
     */
    dst: string; // MAC address of the destnation
    /**
     * @generated from protobuf field: proto.Protocol protocol = 4;
     */
    protocol: Protocol; // Protocol of the message
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "raw";
        /**
         * @generated from protobuf field: proto.Raw raw = 5;
         */
        raw: Raw;
    } | {
        oneofKind: "arp";
        /**
         * @generated from protobuf field: proto.ARP arp = 6;
         */
        arp: ARP;
    } | {
        oneofKind: "icmp";
        /**
         * @generated from protobuf field: proto.ICMP icmp = 7;
         */
        icmp: ICMP;
    } | {
        oneofKind: "icmpv6";
        /**
         * @generated from protobuf field: proto.ICMPv6 icmpv6 = 8;
         */
        icmpv6: ICMPv6;
    } | {
        oneofKind: "dns";
        /**
         * @generated from protobuf field: proto.DNS dns = 9;
         */
        dns: DNS;
    } | {
        oneofKind: "dhcp";
        /**
         * @generated from protobuf field: proto.DHCP dhcp = 10;
         */
        dhcp: DHCP;
    } | {
        oneofKind: "dhcpv6";
        /**
         * @generated from protobuf field: proto.DHCPv6 dhcpv6 = 11;
         */
        dhcpv6: DHCPv6;
    } | {
        oneofKind: "ip";
        /**
         * @generated from protobuf field: proto.IP ip = 12;
         */
        ip: IP;
    } | {
        oneofKind: "ipv6";
        /**
         * @generated from protobuf field: proto.IPv6 ipv6 = 13;
         */
        ipv6: IPv6;
    } | {
        oneofKind: "tcp";
        /**
         * @generated from protobuf field: proto.TCP tcp = 14;
         */
        tcp: TCP;
    } | {
        oneofKind: "udp";
        /**
         * @generated from protobuf field: proto.UDP udp = 15;
         */
        udp: UDP;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message proto.Recording
 */
export interface Recording {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string display_name = 2;
     */
    displayName: string;
    /**
     * @generated from protobuf field: string filename = 3;
     */
    filename: string;
    /**
     * @generated from protobuf field: proto.DataLinkType datalink = 4;
     */
    datalink: DataLinkType;
}
// End of RECORDINGS.proto

/**
 * Empty message
 *
 * @generated from protobuf message proto.Empty
 */
export interface Empty {
}
/**
 * @generated from protobuf message proto.SnifferID
 */
export interface SnifferID {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
}
/**
 * @generated from protobuf message proto.SnifferCreateRequest
 */
export interface SnifferCreateRequest {
    /**
     * @generated from protobuf field: bool is_file_based = 1;
     */
    isFileBased: boolean;
    /**
     * @generated from protobuf field: string net_iface_name = 2;
     */
    netIfaceName: string;
    /**
     * @generated from protobuf field: string recording_uuid = 3;
     */
    recordingUuid: string;
}
/**
 * List many sniffers
 *
 * @generated from protobuf message proto.SnifferListResponse
 */
export interface SnifferListResponse {
    /**
     * @generated from protobuf field: repeated proto.SnifferInfo sniffers = 1;
     */
    sniffers: SnifferInfo[];
}
/**
 * @generated from protobuf message proto.SnifferInfo
 */
export interface SnifferInfo {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: bool is_file_based = 2;
     */
    isFileBased: boolean;
    /**
     * @generated from protobuf field: string net_iface_name = 3;
     */
    netIfaceName: string;
    /**
     * @generated from protobuf field: string filename = 4;
     */
    filename: string;
}
/**
 * @generated from protobuf message proto.BasicNetworkInfo
 */
export interface BasicNetworkInfo {
    /**
     * @generated from protobuf field: string ssid = 1;
     */
    ssid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
}
/**
 * List of networks
 *
 * @generated from protobuf message proto.APListResponse
 */
export interface APListResponse {
    /**
     * @generated from protobuf field: repeated proto.BasicNetworkInfo nets = 1;
     */
    nets: BasicNetworkInfo[];
}
/**
 * @generated from protobuf message proto.APGetRequest
 */
export interface APGetRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
}
/**
 * @generated from protobuf message proto.APGetResponse
 */
export interface APGetResponse {
    /**
     * @generated from protobuf field: proto.AccessPointInfo ap = 1;
     */
    ap?: AccessPointInfo;
}
/**
 * @generated from protobuf message proto.APProvidePasswordRequest
 */
export interface APProvidePasswordRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
    /**
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message proto.APProvidePasswordResponse
 */
export interface APProvidePasswordResponse {
    /**
     * @generated from protobuf field: proto.APProvidePasswordResponse.DecryptionState state = 1;
     */
    state: APProvidePasswordResponse_DecryptionState;
}
/**
 * @generated from protobuf enum proto.APProvidePasswordResponse.DecryptionState
 */
export enum APProvidePasswordResponse_DecryptionState {
    /**
     * Decryption successful, valid pairwise keys generated
     *
     * @generated from protobuf enum value: DECRYPTED = 0;
     */
    DECRYPTED = 0,
    /**
     * Not enough key messages have been discovered to
     *
     * @generated from protobuf enum value: NOT_ENOUGH_DATA = 1;
     */
    NOT_ENOUGH_DATA = 1,
    /**
     * verify password validity
     *
     * Password proven to be incorrect, failed to
     *
     * @generated from protobuf enum value: INCORRECT_PASSWORD = 2;
     */
    INCORRECT_PASSWORD = 2,
    /**
     * generate pairwise keys from key messages
     *
     * @generated from protobuf enum value: ALREADY_DECRYPTED = 3;
     */
    ALREADY_DECRYPTED = 3
}
/**
 * @generated from protobuf message proto.APGetDecryptedStreamRequest
 */
export interface APGetDecryptedStreamRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
    /**
     * @generated from protobuf field: bool include_payload = 3;
     */
    includePayload: boolean;
}
/**
 * @generated from protobuf message proto.APDeauthRequest
 */
export interface APDeauthRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
}
/**
 * @generated from protobuf message proto.APDeauthClientRequest
 */
export interface APDeauthClientRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
    /**
     * @generated from protobuf field: string client_addr = 3;
     */
    clientAddr: string;
}
/**
 * @generated from protobuf message proto.APGetHashRequest
 */
export interface APGetHashRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
    /**
     * @generated from protobuf field: string client_addr = 3;
     */
    clientAddr: string;
}
/**
 * @generated from protobuf message proto.APGetHashResponse
 */
export interface APGetHashResponse {
    /**
     * @generated from protobuf field: string hc22000 = 1;
     */
    hc22000: string;
}
/**
 * @generated from protobuf message proto.APIgnoreRequest
 */
export interface APIgnoreRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: bool use_ssid = 2;
     */
    useSsid: boolean; // Sometimes you want to ignore a whole network instead of
    /**
     * an access point
     *
     * @generated from protobuf field: string bssid = 3;
     */
    bssid: string;
    /**
     * @generated from protobuf field: string ssid = 4;
     */
    ssid: string;
}
/**
 * @generated from protobuf message proto.APCreateRecordingRequest
 */
export interface APCreateRecordingRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string bssid = 3;
     */
    bssid: string;
    /**
     * @generated from protobuf field: bool raw = 4;
     */
    raw: boolean; // Whether to save raw traffic (in the original
}
/**
 * @generated from protobuf message proto.APCreateRecordingResponse
 */
export interface APCreateRecordingResponse {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: uint32 packet_count = 2;
     */
    packetCount: number;
}
/**
 * @generated from protobuf message proto.FocusStartRequest
 */
export interface FocusStartRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string bssid = 2;
     */
    bssid: string;
}
/**
 * @generated from protobuf message proto.FocusStartResponse
 */
export interface FocusStartResponse {
    /**
     * @generated from protobuf field: proto.ChannelInfo channel = 1;
     */
    channel?: ChannelInfo;
}
/**
 * @generated from protobuf message proto.FocusGetActiveResponse
 */
export interface FocusGetActiveResponse {
    /**
     * @generated from protobuf field: string bssid = 1;
     */
    bssid: string;
    /**
     * @generated from protobuf field: string ssid = 2;
     */
    ssid: string;
    /**
     * @generated from protobuf field: proto.ChannelInfo channel = 3;
     */
    channel?: ChannelInfo;
}
/**
 * @generated from protobuf message proto.RecordingCreateRequest
 */
export interface RecordingCreateRequest {
    /**
     * @generated from protobuf field: string sniffer_uuid = 1;
     */
    snifferUuid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bool raw = 3;
     */
    raw: boolean; // If this recording is supposed to be in raw form
}
/**
 * @generated from protobuf message proto.RecordingCreateResponse
 */
export interface RecordingCreateResponse {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: uint32 packet_count = 2;
     */
    packetCount: number;
}
/**
 * @generated from protobuf message proto.RecordingListRequest
 */
export interface RecordingListRequest {
    /**
     * @generated from protobuf field: repeated proto.DataLinkType allowed_types = 1;
     */
    allowedTypes: DataLinkType[];
}
/**
 * @generated from protobuf message proto.RecordingListResponse
 */
export interface RecordingListResponse {
    /**
     * @generated from protobuf field: repeated proto.Recording recordings = 1;
     */
    recordings: Recording[];
}
/**
 * @generated from protobuf message proto.RecordingLoadDecryptedRequest
 */
export interface RecordingLoadDecryptedRequest {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: bool include_payload = 2;
     */
    includePayload: boolean;
}
/**
 * @generated from protobuf message proto.NetworkInterfaceListResponse
 */
export interface NetworkInterfaceListResponse {
    /**
     * @generated from protobuf field: repeated string ifaces = 1;
     */
    ifaces: string[];
}
/**
 * @generated from protobuf message proto.LogEntry
 */
export interface LogEntry {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 1;
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf field: proto.LogEntry.LogLevel level = 2;
     */
    level: LogEntry_LogLevel;
    /**
     * @generated from protobuf field: string scope = 3;
     */
    scope: string;
    /**
     * @generated from protobuf field: string payload = 4;
     */
    payload: string;
}
/**
 * @generated from protobuf enum proto.LogEntry.LogLevel
 */
export enum LogEntry_LogLevel {
    /**
     * @generated from protobuf enum value: TRACE = 0;
     */
    TRACE = 0,
    /**
     * @generated from protobuf enum value: DEBUG = 1;
     */
    DEBUG = 1,
    /**
     * @generated from protobuf enum value: INFO = 2;
     */
    INFO = 2,
    /**
     * @generated from protobuf enum value: WARN = 3;
     */
    WARN = 3,
    /**
     * @generated from protobuf enum value: ERR = 4;
     */
    ERR = 4,
    /**
     * @generated from protobuf enum value: CRITICAL = 5;
     */
    CRITICAL = 5
}
/**
 * @generated from protobuf message proto.BatteryGetLevelResponse
 */
export interface BatteryGetLevelResponse {
    /**
     * @generated from protobuf field: float percentage = 1;
     */
    percentage: number;
}
/**
 * @generated from protobuf enum proto.NetworkSecurity
 */
export enum NetworkSecurity {
    /**
     * @generated from protobuf enum value: OPEN = 0;
     */
    OPEN = 0,
    /**
     * @generated from protobuf enum value: WEP = 1;
     */
    WEP = 1,
    /**
     * @generated from protobuf enum value: WPA = 2;
     */
    WPA = 2,
    /**
     * @generated from protobuf enum value: WPA2_Personal = 3;
     */
    WPA2_Personal = 3,
    /**
     * @generated from protobuf enum value: WPA2_Enterprise = 4;
     */
    WPA2_Enterprise = 4,
    /**
     * @generated from protobuf enum value: WPA3_Personal = 5;
     */
    WPA3_Personal = 5,
    /**
     * @generated from protobuf enum value: WPA3_Enterprise = 6;
     */
    WPA3_Enterprise = 6
}
/**
 * @generated from protobuf enum proto.WiFiStandard
 */
export enum WiFiStandard {
    /**
     * @generated from protobuf enum value: Dot11A = 0;
     */
    Dot11A = 0,
    /**
     * @generated from protobuf enum value: Dot11B = 1;
     */
    Dot11B = 1,
    /**
     * @generated from protobuf enum value: Dot11G = 2;
     */
    Dot11G = 2,
    /**
     * @generated from protobuf enum value: Dot11N = 3;
     */
    Dot11N = 3,
    /**
     * @generated from protobuf enum value: Dot11AC = 4;
     */
    Dot11AC = 4,
    /**
     * @generated from protobuf enum value: Dot11AX = 5;
     */
    Dot11AX = 5
}
/**
 * @generated from protobuf enum proto.Modulation
 */
export enum Modulation {
    /**
     * @generated from protobuf enum value: CCK = 0;
     */
    CCK = 0,
    /**
     * @generated from protobuf enum value: BPSK = 1;
     */
    BPSK = 1,
    /**
     * @generated from protobuf enum value: QPSK = 2;
     */
    QPSK = 2,
    /**
     * @generated from protobuf enum value: QAM16 = 3;
     */
    QAM16 = 3,
    /**
     * @generated from protobuf enum value: QAM64 = 4;
     */
    QAM64 = 4,
    /**
     * @generated from protobuf enum value: QAM256 = 5;
     */
    QAM256 = 5,
    /**
     * @generated from protobuf enum value: QAM1024 = 6;
     */
    QAM1024 = 6
}
/**
 * @generated from protobuf enum proto.ChannelWidth
 */
export enum ChannelWidth {
    /**
     * @generated from protobuf enum value: CHAN20 = 0;
     */
    CHAN20 = 0,
    /**
     * @generated from protobuf enum value: CHAN40 = 1;
     */
    CHAN40 = 1,
    /**
     * @generated from protobuf enum value: CHAN80 = 2;
     */
    CHAN80 = 2,
    /**
     * @generated from protobuf enum value: CHAN80_80 = 3;
     */
    CHAN80_80 = 3,
    /**
     * @generated from protobuf enum value: CHAN160 = 4;
     */
    CHAN160 = 4
}
/**
 * @generated from protobuf enum proto.ChannelType
 */
export enum ChannelType {
    /**
     * @generated from protobuf enum value: NO_HT = 0;
     */
    NO_HT = 0,
    /**
     * @generated from protobuf enum value: HT20 = 1;
     */
    HT20 = 1,
    /**
     * @generated from protobuf enum value: HT40MINUS = 2;
     */
    HT40MINUS = 2,
    /**
     * @generated from protobuf enum value: HT40PLUS = 3;
     */
    HT40PLUS = 3,
    /**
     * @generated from protobuf enum value: VHT80 = 4;
     */
    VHT80 = 4,
    /**
     * @generated from protobuf enum value: VHT80P80 = 5;
     */
    VHT80P80 = 5,
    /**
     * @generated from protobuf enum value: VHT160 = 6;
     */
    VHT160 = 6
}
// End of AP.proto

// PACKETS.proto

/**
 * @generated from protobuf enum proto.Protocol
 */
export enum Protocol {
    /**
     * @generated from protobuf enum value: PROTO_RAW = 0;
     */
    PROTO_RAW = 0,
    /**
     * @generated from protobuf enum value: PROTO_ARP = 1;
     */
    PROTO_ARP = 1,
    /**
     * @generated from protobuf enum value: PROTO_ICMP = 2;
     */
    PROTO_ICMP = 2,
    /**
     * @generated from protobuf enum value: PROTO_ICMPv6 = 3;
     */
    PROTO_ICMPv6 = 3,
    /**
     * @generated from protobuf enum value: PROTO_DNS = 4;
     */
    PROTO_DNS = 4,
    /**
     * @generated from protobuf enum value: PROTO_DHCP = 5;
     */
    PROTO_DHCP = 5,
    /**
     * @generated from protobuf enum value: PROTO_DHCPv6 = 6;
     */
    PROTO_DHCPv6 = 6,
    /**
     * @generated from protobuf enum value: PROTO_IP = 7;
     */
    PROTO_IP = 7,
    /**
     * @generated from protobuf enum value: PROTO_IPv6 = 8;
     */
    PROTO_IPv6 = 8,
    /**
     * @generated from protobuf enum value: PROTO_TCP = 9;
     */
    PROTO_TCP = 9,
    /**
     * @generated from protobuf enum value: PROTO_UDP = 10;
     */
    PROTO_UDP = 10
}
// End of PACKETS.proto

// RECORDINGS.proto

/**
 * @generated from protobuf enum proto.DataLinkType
 */
export enum DataLinkType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: RADIOTAP = 1;
     */
    RADIOTAP = 1,
    /**
     * @generated from protobuf enum value: RAW80211 = 2;
     */
    RAW80211 = 2,
    /**
     * @generated from protobuf enum value: ETH2 = 3;
     */
    ETH2 = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class RadioInfo$Type extends MessageType<RadioInfo> {
    constructor() {
        super("proto.RadioInfo", [
            { no: 8, name: "rssi", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "noise", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "snr", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RadioInfo>): RadioInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rssi = 0;
        message.noise = 0;
        message.snr = 0;
        if (value !== undefined)
            reflectionMergePartial<RadioInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RadioInfo): RadioInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 rssi */ 8:
                    message.rssi = reader.int32();
                    break;
                case /* int32 noise */ 9:
                    message.noise = reader.int32();
                    break;
                case /* int32 snr */ 10:
                    message.snr = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RadioInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 rssi = 8; */
        if (message.rssi !== 0)
            writer.tag(8, WireType.Varint).int32(message.rssi);
        /* int32 noise = 9; */
        if (message.noise !== 0)
            writer.tag(9, WireType.Varint).int32(message.noise);
        /* int32 snr = 10; */
        if (message.snr !== 0)
            writer.tag(10, WireType.Varint).int32(message.snr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.RadioInfo
 */
export const RadioInfo = new RadioInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientWindow$Type extends MessageType<ClientWindow> {
    constructor() {
        super("proto.ClientWindow", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp },
            { no: 2, name: "end", kind: "message", T: () => Timestamp },
            { no: 3, name: "ended", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "decrypted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "auth_packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ptk", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClientWindow>): ClientWindow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ended = false;
        message.decrypted = false;
        message.packetCount = 0;
        message.authPacketCount = 0;
        message.ptk = "";
        if (value !== undefined)
            reflectionMergePartial<ClientWindow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientWindow): ClientWindow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* bool ended */ 3:
                    message.ended = reader.bool();
                    break;
                case /* bool decrypted */ 4:
                    message.decrypted = reader.bool();
                    break;
                case /* uint32 packet_count */ 5:
                    message.packetCount = reader.uint32();
                    break;
                case /* uint32 auth_packet_count */ 6:
                    message.authPacketCount = reader.uint32();
                    break;
                case /* string ptk */ 7:
                    message.ptk = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientWindow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool ended = 3; */
        if (message.ended !== false)
            writer.tag(3, WireType.Varint).bool(message.ended);
        /* bool decrypted = 4; */
        if (message.decrypted !== false)
            writer.tag(4, WireType.Varint).bool(message.decrypted);
        /* uint32 packet_count = 5; */
        if (message.packetCount !== 0)
            writer.tag(5, WireType.Varint).uint32(message.packetCount);
        /* uint32 auth_packet_count = 6; */
        if (message.authPacketCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.authPacketCount);
        /* string ptk = 7; */
        if (message.ptk !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ptk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.ClientWindow
 */
export const ClientWindow = new ClientWindow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientInfo$Type extends MessageType<ClientInfo> {
    constructor() {
        super("proto.ClientInfo", [
            { no: 1, name: "hwaddr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ipv4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ipv6", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "sent_unicast", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "sent_total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "received", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "radio_info", kind: "message", T: () => RadioInfo },
            { no: 9, name: "pmf_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "router", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "current_eapol_pkt_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "windows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClientWindow },
            { no: 13, name: "device_vendor", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClientInfo>): ClientInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hwaddr = "";
        message.hostname = "";
        message.ipv4 = "";
        message.ipv6 = "";
        message.sentUnicast = 0;
        message.sentTotal = 0;
        message.received = 0;
        message.pmfActive = false;
        message.router = false;
        message.currentEapolPktCount = 0;
        message.windows = [];
        message.deviceVendor = "";
        if (value !== undefined)
            reflectionMergePartial<ClientInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientInfo): ClientInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hwaddr */ 1:
                    message.hwaddr = reader.string();
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* string ipv4 */ 3:
                    message.ipv4 = reader.string();
                    break;
                case /* string ipv6 */ 4:
                    message.ipv6 = reader.string();
                    break;
                case /* uint32 sent_unicast */ 5:
                    message.sentUnicast = reader.uint32();
                    break;
                case /* uint32 sent_total */ 6:
                    message.sentTotal = reader.uint32();
                    break;
                case /* uint32 received */ 7:
                    message.received = reader.uint32();
                    break;
                case /* proto.RadioInfo radio_info */ 8:
                    message.radioInfo = RadioInfo.internalBinaryRead(reader, reader.uint32(), options, message.radioInfo);
                    break;
                case /* bool pmf_active */ 9:
                    message.pmfActive = reader.bool();
                    break;
                case /* bool router */ 10:
                    message.router = reader.bool();
                    break;
                case /* uint32 current_eapol_pkt_count */ 11:
                    message.currentEapolPktCount = reader.uint32();
                    break;
                case /* repeated proto.ClientWindow windows */ 12:
                    message.windows.push(ClientWindow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string device_vendor */ 13:
                    message.deviceVendor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hwaddr = 1; */
        if (message.hwaddr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hwaddr);
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string ipv4 = 3; */
        if (message.ipv4 !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ipv4);
        /* string ipv6 = 4; */
        if (message.ipv6 !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ipv6);
        /* uint32 sent_unicast = 5; */
        if (message.sentUnicast !== 0)
            writer.tag(5, WireType.Varint).uint32(message.sentUnicast);
        /* uint32 sent_total = 6; */
        if (message.sentTotal !== 0)
            writer.tag(6, WireType.Varint).uint32(message.sentTotal);
        /* uint32 received = 7; */
        if (message.received !== 0)
            writer.tag(7, WireType.Varint).uint32(message.received);
        /* proto.RadioInfo radio_info = 8; */
        if (message.radioInfo)
            RadioInfo.internalBinaryWrite(message.radioInfo, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool pmf_active = 9; */
        if (message.pmfActive !== false)
            writer.tag(9, WireType.Varint).bool(message.pmfActive);
        /* bool router = 10; */
        if (message.router !== false)
            writer.tag(10, WireType.Varint).bool(message.router);
        /* uint32 current_eapol_pkt_count = 11; */
        if (message.currentEapolPktCount !== 0)
            writer.tag(11, WireType.Varint).uint32(message.currentEapolPktCount);
        /* repeated proto.ClientWindow windows = 12; */
        for (let i = 0; i < message.windows.length; i++)
            ClientWindow.internalBinaryWrite(message.windows[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string device_vendor = 13; */
        if (message.deviceVendor !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.deviceVendor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.ClientInfo
 */
export const ClientInfo = new ClientInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupWindow$Type extends MessageType<GroupWindow> {
    constructor() {
        super("proto.GroupWindow", [
            { no: 1, name: "start", kind: "message", T: () => Timestamp },
            { no: 2, name: "end", kind: "message", T: () => Timestamp },
            { no: 3, name: "ended", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "decrypted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "auth_packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "gtk", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GroupWindow>): GroupWindow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ended = false;
        message.decrypted = false;
        message.packetCount = 0;
        message.authPacketCount = 0;
        message.gtk = "";
        if (value !== undefined)
            reflectionMergePartial<GroupWindow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupWindow): GroupWindow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start */ 1:
                    message.start = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* google.protobuf.Timestamp end */ 2:
                    message.end = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* bool ended */ 3:
                    message.ended = reader.bool();
                    break;
                case /* bool decrypted */ 4:
                    message.decrypted = reader.bool();
                    break;
                case /* uint32 packet_count */ 5:
                    message.packetCount = reader.uint32();
                    break;
                case /* uint32 auth_packet_count */ 6:
                    message.authPacketCount = reader.uint32();
                    break;
                case /* string gtk */ 7:
                    message.gtk = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupWindow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp start = 1; */
        if (message.start)
            Timestamp.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end = 2; */
        if (message.end)
            Timestamp.internalBinaryWrite(message.end, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool ended = 3; */
        if (message.ended !== false)
            writer.tag(3, WireType.Varint).bool(message.ended);
        /* bool decrypted = 4; */
        if (message.decrypted !== false)
            writer.tag(4, WireType.Varint).bool(message.decrypted);
        /* uint32 packet_count = 5; */
        if (message.packetCount !== 0)
            writer.tag(5, WireType.Varint).uint32(message.packetCount);
        /* uint32 auth_packet_count = 6; */
        if (message.authPacketCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.authPacketCount);
        /* string gtk = 7; */
        if (message.gtk !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.gtk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.GroupWindow
 */
export const GroupWindow = new GroupWindow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WiFiStandardInfo$Type extends MessageType<WiFiStandardInfo> {
    constructor() {
        super("proto.WiFiStandardInfo", [
            { no: 1, name: "std", kind: "enum", T: () => ["proto.WiFiStandard", WiFiStandard] },
            { no: 2, name: "single_beamformer_support", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "single_beamformee_support", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "multi_beamformer_support", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "multi_beamformee_support", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "mcs_supported_idx", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "modulation_supported", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["proto.Modulation", Modulation] },
            { no: 8, name: "spatial_streams_supported", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "channel_widths_supported", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["proto.ChannelWidth", ChannelWidth] }
        ]);
    }
    create(value?: PartialMessage<WiFiStandardInfo>): WiFiStandardInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.std = 0;
        message.singleBeamformerSupport = false;
        message.singleBeamformeeSupport = false;
        message.multiBeamformerSupport = false;
        message.multiBeamformeeSupport = false;
        message.mcsSupportedIdx = [];
        message.modulationSupported = [];
        message.spatialStreamsSupported = [];
        message.channelWidthsSupported = [];
        if (value !== undefined)
            reflectionMergePartial<WiFiStandardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WiFiStandardInfo): WiFiStandardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.WiFiStandard std */ 1:
                    message.std = reader.int32();
                    break;
                case /* bool single_beamformer_support */ 2:
                    message.singleBeamformerSupport = reader.bool();
                    break;
                case /* bool single_beamformee_support */ 3:
                    message.singleBeamformeeSupport = reader.bool();
                    break;
                case /* bool multi_beamformer_support */ 4:
                    message.multiBeamformerSupport = reader.bool();
                    break;
                case /* bool multi_beamformee_support */ 5:
                    message.multiBeamformeeSupport = reader.bool();
                    break;
                case /* repeated uint32 mcs_supported_idx */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mcsSupportedIdx.push(reader.uint32());
                    else
                        message.mcsSupportedIdx.push(reader.uint32());
                    break;
                case /* repeated proto.Modulation modulation_supported */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.modulationSupported.push(reader.int32());
                    else
                        message.modulationSupported.push(reader.int32());
                    break;
                case /* repeated uint32 spatial_streams_supported */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.spatialStreamsSupported.push(reader.uint32());
                    else
                        message.spatialStreamsSupported.push(reader.uint32());
                    break;
                case /* repeated proto.ChannelWidth channel_widths_supported */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.channelWidthsSupported.push(reader.int32());
                    else
                        message.channelWidthsSupported.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WiFiStandardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.WiFiStandard std = 1; */
        if (message.std !== 0)
            writer.tag(1, WireType.Varint).int32(message.std);
        /* bool single_beamformer_support = 2; */
        if (message.singleBeamformerSupport !== false)
            writer.tag(2, WireType.Varint).bool(message.singleBeamformerSupport);
        /* bool single_beamformee_support = 3; */
        if (message.singleBeamformeeSupport !== false)
            writer.tag(3, WireType.Varint).bool(message.singleBeamformeeSupport);
        /* bool multi_beamformer_support = 4; */
        if (message.multiBeamformerSupport !== false)
            writer.tag(4, WireType.Varint).bool(message.multiBeamformerSupport);
        /* bool multi_beamformee_support = 5; */
        if (message.multiBeamformeeSupport !== false)
            writer.tag(5, WireType.Varint).bool(message.multiBeamformeeSupport);
        /* repeated uint32 mcs_supported_idx = 6; */
        if (message.mcsSupportedIdx.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mcsSupportedIdx.length; i++)
                writer.uint32(message.mcsSupportedIdx[i]);
            writer.join();
        }
        /* repeated proto.Modulation modulation_supported = 7; */
        if (message.modulationSupported.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.modulationSupported.length; i++)
                writer.int32(message.modulationSupported[i]);
            writer.join();
        }
        /* repeated uint32 spatial_streams_supported = 8; */
        if (message.spatialStreamsSupported.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.spatialStreamsSupported.length; i++)
                writer.uint32(message.spatialStreamsSupported[i]);
            writer.join();
        }
        /* repeated proto.ChannelWidth channel_widths_supported = 9; */
        if (message.channelWidthsSupported.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.channelWidthsSupported.length; i++)
                writer.int32(message.channelWidthsSupported[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.WiFiStandardInfo
 */
export const WiFiStandardInfo = new WiFiStandardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MulticastGroup$Type extends MessageType<MulticastGroup> {
    constructor() {
        super("proto.MulticastGroup", [
            { no: 1, name: "addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MulticastGroup>): MulticastGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addr = "";
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<MulticastGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MulticastGroup): MulticastGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string addr */ 1:
                    message.addr = reader.string();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MulticastGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string addr = 1; */
        if (message.addr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addr);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.MulticastGroup
 */
export const MulticastGroup = new MulticastGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelInfo$Type extends MessageType<ChannelInfo> {
    constructor() {
        super("proto.ChannelInfo", [
            { no: 1, name: "control_frequency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "channel", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["proto.ChannelType", ChannelType] }
        ]);
    }
    create(value?: PartialMessage<ChannelInfo>): ChannelInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.controlFrequency = 0;
        message.channel = 0;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<ChannelInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelInfo): ChannelInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 control_frequency */ 1:
                    message.controlFrequency = reader.uint32();
                    break;
                case /* uint32 channel */ 2:
                    message.channel = reader.uint32();
                    break;
                case /* proto.ChannelType type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 control_frequency = 1; */
        if (message.controlFrequency !== 0)
            writer.tag(1, WireType.Varint).uint32(message.controlFrequency);
        /* uint32 channel = 2; */
        if (message.channel !== 0)
            writer.tag(2, WireType.Varint).uint32(message.channel);
        /* proto.ChannelType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.ChannelInfo
 */
export const ChannelInfo = new ChannelInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessPointInfo$Type extends MessageType<AccessPointInfo> {
    constructor() {
        super("proto.AccessPointInfo", [
            { no: 1, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "encrypted_packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "decrypted_packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "radio_info", kind: "message", T: () => RadioInfo },
            { no: 6, name: "pmf_capable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "pmf_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "supported_chanels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChannelInfo },
            { no: 9, name: "supported_standards", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WiFiStandardInfo },
            { no: 10, name: "multicast_groups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MulticastGroup },
            { no: 11, name: "security", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["proto.NetworkSecurity", NetworkSecurity] },
            { no: 12, name: "clients", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClientInfo },
            { no: 13, name: "group_windows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GroupWindow },
            { no: 14, name: "device_vendor", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccessPointInfo>): AccessPointInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ssid = "";
        message.bssid = "";
        message.encryptedPacketCount = 0;
        message.decryptedPacketCount = 0;
        message.pmfCapable = false;
        message.pmfRequired = false;
        message.supportedChanels = [];
        message.supportedStandards = [];
        message.multicastGroups = [];
        message.security = [];
        message.clients = [];
        message.groupWindows = [];
        message.deviceVendor = "";
        if (value !== undefined)
            reflectionMergePartial<AccessPointInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessPointInfo): AccessPointInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ssid */ 1:
                    message.ssid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                case /* uint32 encrypted_packet_count */ 3:
                    message.encryptedPacketCount = reader.uint32();
                    break;
                case /* uint32 decrypted_packet_count */ 4:
                    message.decryptedPacketCount = reader.uint32();
                    break;
                case /* proto.RadioInfo radio_info */ 5:
                    message.radioInfo = RadioInfo.internalBinaryRead(reader, reader.uint32(), options, message.radioInfo);
                    break;
                case /* bool pmf_capable */ 6:
                    message.pmfCapable = reader.bool();
                    break;
                case /* bool pmf_required */ 7:
                    message.pmfRequired = reader.bool();
                    break;
                case /* repeated proto.ChannelInfo supported_chanels */ 8:
                    message.supportedChanels.push(ChannelInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.WiFiStandardInfo supported_standards */ 9:
                    message.supportedStandards.push(WiFiStandardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.MulticastGroup multicast_groups */ 10:
                    message.multicastGroups.push(MulticastGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.NetworkSecurity security */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.security.push(reader.int32());
                    else
                        message.security.push(reader.int32());
                    break;
                case /* repeated proto.ClientInfo clients */ 12:
                    message.clients.push(ClientInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.GroupWindow group_windows */ 13:
                    message.groupWindows.push(GroupWindow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string device_vendor */ 14:
                    message.deviceVendor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessPointInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ssid = 1; */
        if (message.ssid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ssid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        /* uint32 encrypted_packet_count = 3; */
        if (message.encryptedPacketCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.encryptedPacketCount);
        /* uint32 decrypted_packet_count = 4; */
        if (message.decryptedPacketCount !== 0)
            writer.tag(4, WireType.Varint).uint32(message.decryptedPacketCount);
        /* proto.RadioInfo radio_info = 5; */
        if (message.radioInfo)
            RadioInfo.internalBinaryWrite(message.radioInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool pmf_capable = 6; */
        if (message.pmfCapable !== false)
            writer.tag(6, WireType.Varint).bool(message.pmfCapable);
        /* bool pmf_required = 7; */
        if (message.pmfRequired !== false)
            writer.tag(7, WireType.Varint).bool(message.pmfRequired);
        /* repeated proto.ChannelInfo supported_chanels = 8; */
        for (let i = 0; i < message.supportedChanels.length; i++)
            ChannelInfo.internalBinaryWrite(message.supportedChanels[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.WiFiStandardInfo supported_standards = 9; */
        for (let i = 0; i < message.supportedStandards.length; i++)
            WiFiStandardInfo.internalBinaryWrite(message.supportedStandards[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.MulticastGroup multicast_groups = 10; */
        for (let i = 0; i < message.multicastGroups.length; i++)
            MulticastGroup.internalBinaryWrite(message.multicastGroups[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.NetworkSecurity security = 11; */
        if (message.security.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.security.length; i++)
                writer.int32(message.security[i]);
            writer.join();
        }
        /* repeated proto.ClientInfo clients = 12; */
        for (let i = 0; i < message.clients.length; i++)
            ClientInfo.internalBinaryWrite(message.clients[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.GroupWindow group_windows = 13; */
        for (let i = 0; i < message.groupWindows.length; i++)
            GroupWindow.internalBinaryWrite(message.groupWindows[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string device_vendor = 14; */
        if (message.deviceVendor !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.deviceVendor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.AccessPointInfo
 */
export const AccessPointInfo = new AccessPointInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Raw$Type extends MessageType<Raw> {
    constructor() {
        super("proto.Raw", [
            { no: 1, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Raw>): Raw {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Raw>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Raw): Raw {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payload */ 1:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Raw, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payload = 1; */
        if (message.payload.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.Raw
 */
export const Raw = new Raw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ARP$Type extends MessageType<ARP> {
    constructor() {
        super("proto.ARP", [
            { no: 1, name: "sender_ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sender_mac_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "target_mac_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ARP>): ARP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senderIpAddress = "";
        message.senderMacAddress = "";
        message.targetIpAddress = "";
        message.targetMacAddress = "";
        if (value !== undefined)
            reflectionMergePartial<ARP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ARP): ARP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender_ip_address */ 1:
                    message.senderIpAddress = reader.string();
                    break;
                case /* string sender_mac_address */ 2:
                    message.senderMacAddress = reader.string();
                    break;
                case /* string target_ip_address */ 3:
                    message.targetIpAddress = reader.string();
                    break;
                case /* string target_mac_address */ 4:
                    message.targetMacAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ARP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender_ip_address = 1; */
        if (message.senderIpAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.senderIpAddress);
        /* string sender_mac_address = 2; */
        if (message.senderMacAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.senderMacAddress);
        /* string target_ip_address = 3; */
        if (message.targetIpAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetIpAddress);
        /* string target_mac_address = 4; */
        if (message.targetMacAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.targetMacAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.ARP
 */
export const ARP = new ARP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ICMP$Type extends MessageType<ICMP> {
    constructor() {
        super("proto.ICMP", [
            { no: 1, name: "type", kind: "enum", T: () => ["proto.ICMP.Type", ICMP_Type] },
            { no: 2, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ICMP>): ICMP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.code = 0;
        if (value !== undefined)
            reflectionMergePartial<ICMP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ICMP): ICMP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.ICMP.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* uint32 code */ 2:
                    message.code = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ICMP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.ICMP.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* uint32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).uint32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.ICMP
 */
export const ICMP = new ICMP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ICMPv6$Type extends MessageType<ICMPv6> {
    constructor() {
        super("proto.ICMPv6", [
            { no: 1, name: "type", kind: "enum", T: () => ["proto.ICMPv6.Type", ICMPv6_Type] },
            { no: 2, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "checksum", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ICMPv6>): ICMPv6 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.code = 0;
        message.checksum = 0;
        if (value !== undefined)
            reflectionMergePartial<ICMPv6>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ICMPv6): ICMPv6 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.ICMPv6.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* uint32 code */ 2:
                    message.code = reader.uint32();
                    break;
                case /* uint32 checksum */ 3:
                    message.checksum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ICMPv6, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.ICMPv6.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* uint32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).uint32(message.code);
        /* uint32 checksum = 3; */
        if (message.checksum !== 0)
            writer.tag(3, WireType.Varint).uint32(message.checksum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.ICMPv6
 */
export const ICMPv6 = new ICMPv6$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DNS$Type extends MessageType<DNS> {
    constructor() {
        super("proto.DNS", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "qr", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "questions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DNS_Question },
            { no: 4, name: "answers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DNS_ResourceRecord }
        ]);
    }
    create(value?: PartialMessage<DNS>): DNS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.qr = false;
        message.questions = [];
        message.answers = [];
        if (value !== undefined)
            reflectionMergePartial<DNS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DNS): DNS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* bool qr */ 2:
                    message.qr = reader.bool();
                    break;
                case /* repeated proto.DNS.Question questions */ 3:
                    message.questions.push(DNS_Question.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.DNS.ResourceRecord answers */ 4:
                    message.answers.push(DNS_ResourceRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DNS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* bool qr = 2; */
        if (message.qr !== false)
            writer.tag(2, WireType.Varint).bool(message.qr);
        /* repeated proto.DNS.Question questions = 3; */
        for (let i = 0; i < message.questions.length; i++)
            DNS_Question.internalBinaryWrite(message.questions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.DNS.ResourceRecord answers = 4; */
        for (let i = 0; i < message.answers.length; i++)
            DNS_ResourceRecord.internalBinaryWrite(message.answers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.DNS
 */
export const DNS = new DNS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DNS_Question$Type extends MessageType<DNS_Question> {
    constructor() {
        super("proto.DNS.Question", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DNS_Question>): DNS_Question {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<DNS_Question>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DNS_Question): DNS_Question {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 type */ 2:
                    message.type = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DNS_Question, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).uint32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.DNS.Question
 */
export const DNS_Question = new DNS_Question$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DNS_ResourceRecord$Type extends MessageType<DNS_ResourceRecord> {
    constructor() {
        super("proto.DNS.ResourceRecord", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DNS_ResourceRecord>): DNS_ResourceRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = 0;
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<DNS_ResourceRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DNS_ResourceRecord): DNS_ResourceRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 type */ 2:
                    message.type = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DNS_ResourceRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).uint32(message.type);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.DNS.ResourceRecord
 */
export const DNS_ResourceRecord = new DNS_ResourceRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DHCP$Type extends MessageType<DHCP> {
    constructor() {
        super("proto.DHCP", [
            { no: 1, name: "message_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "transaction_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "client_ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "your_ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "server_ip_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "client_mac_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DHCP>): DHCP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageType = 0;
        message.transactionId = 0;
        message.clientIpAddress = "";
        message.yourIpAddress = "";
        message.serverIpAddress = "";
        message.clientMacAddress = "";
        if (value !== undefined)
            reflectionMergePartial<DHCP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DHCP): DHCP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 message_type */ 1:
                    message.messageType = reader.uint32();
                    break;
                case /* uint32 transaction_id */ 2:
                    message.transactionId = reader.uint32();
                    break;
                case /* string client_ip_address */ 3:
                    message.clientIpAddress = reader.string();
                    break;
                case /* string your_ip_address */ 4:
                    message.yourIpAddress = reader.string();
                    break;
                case /* string server_ip_address */ 5:
                    message.serverIpAddress = reader.string();
                    break;
                case /* string client_mac_address */ 6:
                    message.clientMacAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DHCP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 message_type = 1; */
        if (message.messageType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.messageType);
        /* uint32 transaction_id = 2; */
        if (message.transactionId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.transactionId);
        /* string client_ip_address = 3; */
        if (message.clientIpAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.clientIpAddress);
        /* string your_ip_address = 4; */
        if (message.yourIpAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.yourIpAddress);
        /* string server_ip_address = 5; */
        if (message.serverIpAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.serverIpAddress);
        /* string client_mac_address = 6; */
        if (message.clientMacAddress !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.clientMacAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.DHCP
 */
export const DHCP = new DHCP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DHCPv6$Type extends MessageType<DHCPv6> {
    constructor() {
        super("proto.DHCPv6", [
            { no: 1, name: "message_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "transaction_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DHCPv6_Option }
        ]);
    }
    create(value?: PartialMessage<DHCPv6>): DHCPv6 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageType = 0;
        message.transactionId = 0;
        message.options = [];
        if (value !== undefined)
            reflectionMergePartial<DHCPv6>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DHCPv6): DHCPv6 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 message_type */ 1:
                    message.messageType = reader.uint32();
                    break;
                case /* uint32 transaction_id */ 2:
                    message.transactionId = reader.uint32();
                    break;
                case /* repeated proto.DHCPv6.Option options */ 3:
                    message.options.push(DHCPv6_Option.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DHCPv6, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 message_type = 1; */
        if (message.messageType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.messageType);
        /* uint32 transaction_id = 2; */
        if (message.transactionId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.transactionId);
        /* repeated proto.DHCPv6.Option options = 3; */
        for (let i = 0; i < message.options.length; i++)
            DHCPv6_Option.internalBinaryWrite(message.options[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.DHCPv6
 */
export const DHCPv6 = new DHCPv6$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DHCPv6_Option$Type extends MessageType<DHCPv6_Option> {
    constructor() {
        super("proto.DHCPv6.Option", [
            { no: 1, name: "option_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "option_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "option_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DHCPv6_Option>): DHCPv6_Option {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.optionCode = 0;
        message.optionLength = 0;
        message.optionData = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<DHCPv6_Option>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DHCPv6_Option): DHCPv6_Option {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 option_code */ 1:
                    message.optionCode = reader.uint32();
                    break;
                case /* uint32 option_length */ 2:
                    message.optionLength = reader.uint32();
                    break;
                case /* bytes option_data */ 3:
                    message.optionData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DHCPv6_Option, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 option_code = 1; */
        if (message.optionCode !== 0)
            writer.tag(1, WireType.Varint).uint32(message.optionCode);
        /* uint32 option_length = 2; */
        if (message.optionLength !== 0)
            writer.tag(2, WireType.Varint).uint32(message.optionLength);
        /* bytes option_data = 3; */
        if (message.optionData.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.optionData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.DHCPv6.Option
 */
export const DHCPv6_Option = new DHCPv6_Option$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IP$Type extends MessageType<IP> {
    constructor() {
        super("proto.IP", [
            { no: 1, name: "source_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "destination_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ttl", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "protocol", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "total_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "next_protocol", kind: "enum", T: () => ["proto.Protocol", Protocol] },
            { no: 8, name: "icmp", kind: "message", oneof: "next", T: () => ICMP },
            { no: 9, name: "tcp", kind: "message", oneof: "next", T: () => TCP },
            { no: 10, name: "udp", kind: "message", oneof: "next", T: () => UDP }
        ]);
    }
    create(value?: PartialMessage<IP>): IP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourceAddress = "";
        message.destinationAddress = "";
        message.ttl = 0;
        message.protocol = 0;
        message.totalLength = 0;
        message.payload = new Uint8Array(0);
        message.nextProtocol = 0;
        message.next = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<IP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IP): IP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source_address */ 1:
                    message.sourceAddress = reader.string();
                    break;
                case /* string destination_address */ 2:
                    message.destinationAddress = reader.string();
                    break;
                case /* uint32 ttl */ 3:
                    message.ttl = reader.uint32();
                    break;
                case /* uint32 protocol */ 4:
                    message.protocol = reader.uint32();
                    break;
                case /* uint32 total_length */ 5:
                    message.totalLength = reader.uint32();
                    break;
                case /* bytes payload */ 6:
                    message.payload = reader.bytes();
                    break;
                case /* proto.Protocol next_protocol */ 7:
                    message.nextProtocol = reader.int32();
                    break;
                case /* proto.ICMP icmp */ 8:
                    message.next = {
                        oneofKind: "icmp",
                        icmp: ICMP.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).icmp)
                    };
                    break;
                case /* proto.TCP tcp */ 9:
                    message.next = {
                        oneofKind: "tcp",
                        tcp: TCP.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).tcp)
                    };
                    break;
                case /* proto.UDP udp */ 10:
                    message.next = {
                        oneofKind: "udp",
                        udp: UDP.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).udp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source_address = 1; */
        if (message.sourceAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sourceAddress);
        /* string destination_address = 2; */
        if (message.destinationAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.destinationAddress);
        /* uint32 ttl = 3; */
        if (message.ttl !== 0)
            writer.tag(3, WireType.Varint).uint32(message.ttl);
        /* uint32 protocol = 4; */
        if (message.protocol !== 0)
            writer.tag(4, WireType.Varint).uint32(message.protocol);
        /* uint32 total_length = 5; */
        if (message.totalLength !== 0)
            writer.tag(5, WireType.Varint).uint32(message.totalLength);
        /* bytes payload = 6; */
        if (message.payload.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.payload);
        /* proto.Protocol next_protocol = 7; */
        if (message.nextProtocol !== 0)
            writer.tag(7, WireType.Varint).int32(message.nextProtocol);
        /* proto.ICMP icmp = 8; */
        if (message.next.oneofKind === "icmp")
            ICMP.internalBinaryWrite(message.next.icmp, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* proto.TCP tcp = 9; */
        if (message.next.oneofKind === "tcp")
            TCP.internalBinaryWrite(message.next.tcp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* proto.UDP udp = 10; */
        if (message.next.oneofKind === "udp")
            UDP.internalBinaryWrite(message.next.udp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.IP
 */
export const IP = new IP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IPv6$Type extends MessageType<IPv6> {
    constructor() {
        super("proto.IPv6", [
            { no: 1, name: "source_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "destination_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hop_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "next_header", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "payload_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "next_protocol", kind: "enum", T: () => ["proto.Protocol", Protocol] },
            { no: 8, name: "icmpv6", kind: "message", oneof: "next", T: () => ICMPv6 },
            { no: 9, name: "tcp", kind: "message", oneof: "next", T: () => TCP },
            { no: 10, name: "udp", kind: "message", oneof: "next", T: () => UDP }
        ]);
    }
    create(value?: PartialMessage<IPv6>): IPv6 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourceAddress = "";
        message.destinationAddress = "";
        message.hopLimit = 0;
        message.nextHeader = 0;
        message.payloadLength = 0;
        message.payload = new Uint8Array(0);
        message.nextProtocol = 0;
        message.next = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<IPv6>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IPv6): IPv6 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source_address */ 1:
                    message.sourceAddress = reader.string();
                    break;
                case /* string destination_address */ 2:
                    message.destinationAddress = reader.string();
                    break;
                case /* uint32 hop_limit */ 3:
                    message.hopLimit = reader.uint32();
                    break;
                case /* uint32 next_header */ 4:
                    message.nextHeader = reader.uint32();
                    break;
                case /* uint32 payload_length */ 5:
                    message.payloadLength = reader.uint32();
                    break;
                case /* bytes payload */ 6:
                    message.payload = reader.bytes();
                    break;
                case /* proto.Protocol next_protocol */ 7:
                    message.nextProtocol = reader.int32();
                    break;
                case /* proto.ICMPv6 icmpv6 */ 8:
                    message.next = {
                        oneofKind: "icmpv6",
                        icmpv6: ICMPv6.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).icmpv6)
                    };
                    break;
                case /* proto.TCP tcp */ 9:
                    message.next = {
                        oneofKind: "tcp",
                        tcp: TCP.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).tcp)
                    };
                    break;
                case /* proto.UDP udp */ 10:
                    message.next = {
                        oneofKind: "udp",
                        udp: UDP.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).udp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IPv6, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source_address = 1; */
        if (message.sourceAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sourceAddress);
        /* string destination_address = 2; */
        if (message.destinationAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.destinationAddress);
        /* uint32 hop_limit = 3; */
        if (message.hopLimit !== 0)
            writer.tag(3, WireType.Varint).uint32(message.hopLimit);
        /* uint32 next_header = 4; */
        if (message.nextHeader !== 0)
            writer.tag(4, WireType.Varint).uint32(message.nextHeader);
        /* uint32 payload_length = 5; */
        if (message.payloadLength !== 0)
            writer.tag(5, WireType.Varint).uint32(message.payloadLength);
        /* bytes payload = 6; */
        if (message.payload.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.payload);
        /* proto.Protocol next_protocol = 7; */
        if (message.nextProtocol !== 0)
            writer.tag(7, WireType.Varint).int32(message.nextProtocol);
        /* proto.ICMPv6 icmpv6 = 8; */
        if (message.next.oneofKind === "icmpv6")
            ICMPv6.internalBinaryWrite(message.next.icmpv6, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* proto.TCP tcp = 9; */
        if (message.next.oneofKind === "tcp")
            TCP.internalBinaryWrite(message.next.tcp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* proto.UDP udp = 10; */
        if (message.next.oneofKind === "udp")
            UDP.internalBinaryWrite(message.next.udp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.IPv6
 */
export const IPv6 = new IPv6$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TCP$Type extends MessageType<TCP> {
    constructor() {
        super("proto.TCP", [
            { no: 1, name: "source_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "destination_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "sequence_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "acknowledgment_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "window_size", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "syn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "ack", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "fin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TCP>): TCP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourcePort = 0;
        message.destinationPort = 0;
        message.sequenceNumber = 0;
        message.acknowledgmentNumber = 0;
        message.windowSize = 0;
        message.syn = false;
        message.ack = false;
        message.fin = false;
        if (value !== undefined)
            reflectionMergePartial<TCP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TCP): TCP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 source_port */ 1:
                    message.sourcePort = reader.uint32();
                    break;
                case /* uint32 destination_port */ 2:
                    message.destinationPort = reader.uint32();
                    break;
                case /* uint32 sequence_number */ 3:
                    message.sequenceNumber = reader.uint32();
                    break;
                case /* uint32 acknowledgment_number */ 4:
                    message.acknowledgmentNumber = reader.uint32();
                    break;
                case /* uint32 window_size */ 5:
                    message.windowSize = reader.uint32();
                    break;
                case /* bool syn */ 6:
                    message.syn = reader.bool();
                    break;
                case /* bool ack */ 7:
                    message.ack = reader.bool();
                    break;
                case /* bool fin */ 8:
                    message.fin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TCP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 source_port = 1; */
        if (message.sourcePort !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sourcePort);
        /* uint32 destination_port = 2; */
        if (message.destinationPort !== 0)
            writer.tag(2, WireType.Varint).uint32(message.destinationPort);
        /* uint32 sequence_number = 3; */
        if (message.sequenceNumber !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sequenceNumber);
        /* uint32 acknowledgment_number = 4; */
        if (message.acknowledgmentNumber !== 0)
            writer.tag(4, WireType.Varint).uint32(message.acknowledgmentNumber);
        /* uint32 window_size = 5; */
        if (message.windowSize !== 0)
            writer.tag(5, WireType.Varint).uint32(message.windowSize);
        /* bool syn = 6; */
        if (message.syn !== false)
            writer.tag(6, WireType.Varint).bool(message.syn);
        /* bool ack = 7; */
        if (message.ack !== false)
            writer.tag(7, WireType.Varint).bool(message.ack);
        /* bool fin = 8; */
        if (message.fin !== false)
            writer.tag(8, WireType.Varint).bool(message.fin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.TCP
 */
export const TCP = new TCP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UDP$Type extends MessageType<UDP> {
    constructor() {
        super("proto.UDP", [
            { no: 1, name: "source_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "destination_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "next_protocol", kind: "enum", T: () => ["proto.Protocol", Protocol] },
            { no: 5, name: "dns", kind: "message", oneof: "next", T: () => DNS },
            { no: 6, name: "dhcp", kind: "message", oneof: "next", T: () => DHCP },
            { no: 7, name: "dhcpv6", kind: "message", oneof: "next", T: () => DHCPv6 }
        ]);
    }
    create(value?: PartialMessage<UDP>): UDP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourcePort = 0;
        message.destinationPort = 0;
        message.nextProtocol = 0;
        message.next = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<UDP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UDP): UDP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 source_port */ 1:
                    message.sourcePort = reader.uint32();
                    break;
                case /* uint32 destination_port */ 2:
                    message.destinationPort = reader.uint32();
                    break;
                case /* proto.Protocol next_protocol */ 4:
                    message.nextProtocol = reader.int32();
                    break;
                case /* proto.DNS dns */ 5:
                    message.next = {
                        oneofKind: "dns",
                        dns: DNS.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).dns)
                    };
                    break;
                case /* proto.DHCP dhcp */ 6:
                    message.next = {
                        oneofKind: "dhcp",
                        dhcp: DHCP.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).dhcp)
                    };
                    break;
                case /* proto.DHCPv6 dhcpv6 */ 7:
                    message.next = {
                        oneofKind: "dhcpv6",
                        dhcpv6: DHCPv6.internalBinaryRead(reader, reader.uint32(), options, (message.next as any).dhcpv6)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UDP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 source_port = 1; */
        if (message.sourcePort !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sourcePort);
        /* uint32 destination_port = 2; */
        if (message.destinationPort !== 0)
            writer.tag(2, WireType.Varint).uint32(message.destinationPort);
        /* proto.Protocol next_protocol = 4; */
        if (message.nextProtocol !== 0)
            writer.tag(4, WireType.Varint).int32(message.nextProtocol);
        /* proto.DNS dns = 5; */
        if (message.next.oneofKind === "dns")
            DNS.internalBinaryWrite(message.next.dns, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto.DHCP dhcp = 6; */
        if (message.next.oneofKind === "dhcp")
            DHCP.internalBinaryWrite(message.next.dhcp, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* proto.DHCPv6 dhcpv6 = 7; */
        if (message.next.oneofKind === "dhcpv6")
            DHCPv6.internalBinaryWrite(message.next.dhcpv6, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.UDP
 */
export const UDP = new UDP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Packet$Type extends MessageType<Packet> {
    constructor() {
        super("proto.Packet", [
            { no: 1, name: "capture_time", kind: "message", T: () => Timestamp },
            { no: 2, name: "src", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dst", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "protocol", kind: "enum", T: () => ["proto.Protocol", Protocol] },
            { no: 5, name: "raw", kind: "message", oneof: "data", T: () => Raw },
            { no: 6, name: "arp", kind: "message", oneof: "data", T: () => ARP },
            { no: 7, name: "icmp", kind: "message", oneof: "data", T: () => ICMP },
            { no: 8, name: "icmpv6", kind: "message", oneof: "data", T: () => ICMPv6 },
            { no: 9, name: "dns", kind: "message", oneof: "data", T: () => DNS },
            { no: 10, name: "dhcp", kind: "message", oneof: "data", T: () => DHCP },
            { no: 11, name: "dhcpv6", kind: "message", oneof: "data", T: () => DHCPv6 },
            { no: 12, name: "ip", kind: "message", oneof: "data", T: () => IP },
            { no: 13, name: "ipv6", kind: "message", oneof: "data", T: () => IPv6 },
            { no: 14, name: "tcp", kind: "message", oneof: "data", T: () => TCP },
            { no: 15, name: "udp", kind: "message", oneof: "data", T: () => UDP }
        ]);
    }
    create(value?: PartialMessage<Packet>): Packet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.src = "";
        message.dst = "";
        message.protocol = 0;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Packet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Packet): Packet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp capture_time */ 1:
                    message.captureTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.captureTime);
                    break;
                case /* string src */ 2:
                    message.src = reader.string();
                    break;
                case /* string dst */ 3:
                    message.dst = reader.string();
                    break;
                case /* proto.Protocol protocol */ 4:
                    message.protocol = reader.int32();
                    break;
                case /* proto.Raw raw */ 5:
                    message.data = {
                        oneofKind: "raw",
                        raw: Raw.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).raw)
                    };
                    break;
                case /* proto.ARP arp */ 6:
                    message.data = {
                        oneofKind: "arp",
                        arp: ARP.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).arp)
                    };
                    break;
                case /* proto.ICMP icmp */ 7:
                    message.data = {
                        oneofKind: "icmp",
                        icmp: ICMP.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).icmp)
                    };
                    break;
                case /* proto.ICMPv6 icmpv6 */ 8:
                    message.data = {
                        oneofKind: "icmpv6",
                        icmpv6: ICMPv6.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).icmpv6)
                    };
                    break;
                case /* proto.DNS dns */ 9:
                    message.data = {
                        oneofKind: "dns",
                        dns: DNS.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).dns)
                    };
                    break;
                case /* proto.DHCP dhcp */ 10:
                    message.data = {
                        oneofKind: "dhcp",
                        dhcp: DHCP.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).dhcp)
                    };
                    break;
                case /* proto.DHCPv6 dhcpv6 */ 11:
                    message.data = {
                        oneofKind: "dhcpv6",
                        dhcpv6: DHCPv6.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).dhcpv6)
                    };
                    break;
                case /* proto.IP ip */ 12:
                    message.data = {
                        oneofKind: "ip",
                        ip: IP.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).ip)
                    };
                    break;
                case /* proto.IPv6 ipv6 */ 13:
                    message.data = {
                        oneofKind: "ipv6",
                        ipv6: IPv6.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).ipv6)
                    };
                    break;
                case /* proto.TCP tcp */ 14:
                    message.data = {
                        oneofKind: "tcp",
                        tcp: TCP.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).tcp)
                    };
                    break;
                case /* proto.UDP udp */ 15:
                    message.data = {
                        oneofKind: "udp",
                        udp: UDP.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).udp)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Packet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp capture_time = 1; */
        if (message.captureTime)
            Timestamp.internalBinaryWrite(message.captureTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string src = 2; */
        if (message.src !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.src);
        /* string dst = 3; */
        if (message.dst !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dst);
        /* proto.Protocol protocol = 4; */
        if (message.protocol !== 0)
            writer.tag(4, WireType.Varint).int32(message.protocol);
        /* proto.Raw raw = 5; */
        if (message.data.oneofKind === "raw")
            Raw.internalBinaryWrite(message.data.raw, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto.ARP arp = 6; */
        if (message.data.oneofKind === "arp")
            ARP.internalBinaryWrite(message.data.arp, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* proto.ICMP icmp = 7; */
        if (message.data.oneofKind === "icmp")
            ICMP.internalBinaryWrite(message.data.icmp, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* proto.ICMPv6 icmpv6 = 8; */
        if (message.data.oneofKind === "icmpv6")
            ICMPv6.internalBinaryWrite(message.data.icmpv6, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* proto.DNS dns = 9; */
        if (message.data.oneofKind === "dns")
            DNS.internalBinaryWrite(message.data.dns, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* proto.DHCP dhcp = 10; */
        if (message.data.oneofKind === "dhcp")
            DHCP.internalBinaryWrite(message.data.dhcp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* proto.DHCPv6 dhcpv6 = 11; */
        if (message.data.oneofKind === "dhcpv6")
            DHCPv6.internalBinaryWrite(message.data.dhcpv6, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* proto.IP ip = 12; */
        if (message.data.oneofKind === "ip")
            IP.internalBinaryWrite(message.data.ip, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* proto.IPv6 ipv6 = 13; */
        if (message.data.oneofKind === "ipv6")
            IPv6.internalBinaryWrite(message.data.ipv6, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* proto.TCP tcp = 14; */
        if (message.data.oneofKind === "tcp")
            TCP.internalBinaryWrite(message.data.tcp, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* proto.UDP udp = 15; */
        if (message.data.oneofKind === "udp")
            UDP.internalBinaryWrite(message.data.udp, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.Packet
 */
export const Packet = new Packet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Recording$Type extends MessageType<Recording> {
    constructor() {
        super("proto.Recording", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "filename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "datalink", kind: "enum", T: () => ["proto.DataLinkType", DataLinkType] }
        ]);
    }
    create(value?: PartialMessage<Recording>): Recording {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.displayName = "";
        message.filename = "";
        message.datalink = 0;
        if (value !== undefined)
            reflectionMergePartial<Recording>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Recording): Recording {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                case /* string filename */ 3:
                    message.filename = reader.string();
                    break;
                case /* proto.DataLinkType datalink */ 4:
                    message.datalink = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Recording, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string display_name = 2; */
        if (message.displayName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.displayName);
        /* string filename = 3; */
        if (message.filename !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.filename);
        /* proto.DataLinkType datalink = 4; */
        if (message.datalink !== 0)
            writer.tag(4, WireType.Varint).int32(message.datalink);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.Recording
 */
export const Recording = new Recording$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("proto.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SnifferID$Type extends MessageType<SnifferID> {
    constructor() {
        super("proto.SnifferID", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SnifferID>): SnifferID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        if (value !== undefined)
            reflectionMergePartial<SnifferID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SnifferID): SnifferID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SnifferID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.SnifferID
 */
export const SnifferID = new SnifferID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SnifferCreateRequest$Type extends MessageType<SnifferCreateRequest> {
    constructor() {
        super("proto.SnifferCreateRequest", [
            { no: 1, name: "is_file_based", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "net_iface_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "recording_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SnifferCreateRequest>): SnifferCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isFileBased = false;
        message.netIfaceName = "";
        message.recordingUuid = "";
        if (value !== undefined)
            reflectionMergePartial<SnifferCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SnifferCreateRequest): SnifferCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_file_based */ 1:
                    message.isFileBased = reader.bool();
                    break;
                case /* string net_iface_name */ 2:
                    message.netIfaceName = reader.string();
                    break;
                case /* string recording_uuid */ 3:
                    message.recordingUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SnifferCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_file_based = 1; */
        if (message.isFileBased !== false)
            writer.tag(1, WireType.Varint).bool(message.isFileBased);
        /* string net_iface_name = 2; */
        if (message.netIfaceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.netIfaceName);
        /* string recording_uuid = 3; */
        if (message.recordingUuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.recordingUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.SnifferCreateRequest
 */
export const SnifferCreateRequest = new SnifferCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SnifferListResponse$Type extends MessageType<SnifferListResponse> {
    constructor() {
        super("proto.SnifferListResponse", [
            { no: 1, name: "sniffers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SnifferInfo }
        ]);
    }
    create(value?: PartialMessage<SnifferListResponse>): SnifferListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sniffers = [];
        if (value !== undefined)
            reflectionMergePartial<SnifferListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SnifferListResponse): SnifferListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.SnifferInfo sniffers */ 1:
                    message.sniffers.push(SnifferInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SnifferListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.SnifferInfo sniffers = 1; */
        for (let i = 0; i < message.sniffers.length; i++)
            SnifferInfo.internalBinaryWrite(message.sniffers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.SnifferListResponse
 */
export const SnifferListResponse = new SnifferListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SnifferInfo$Type extends MessageType<SnifferInfo> {
    constructor() {
        super("proto.SnifferInfo", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_file_based", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "net_iface_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "filename", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SnifferInfo>): SnifferInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.isFileBased = false;
        message.netIfaceName = "";
        message.filename = "";
        if (value !== undefined)
            reflectionMergePartial<SnifferInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SnifferInfo): SnifferInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* bool is_file_based */ 2:
                    message.isFileBased = reader.bool();
                    break;
                case /* string net_iface_name */ 3:
                    message.netIfaceName = reader.string();
                    break;
                case /* string filename */ 4:
                    message.filename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SnifferInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* bool is_file_based = 2; */
        if (message.isFileBased !== false)
            writer.tag(2, WireType.Varint).bool(message.isFileBased);
        /* string net_iface_name = 3; */
        if (message.netIfaceName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.netIfaceName);
        /* string filename = 4; */
        if (message.filename !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.filename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.SnifferInfo
 */
export const SnifferInfo = new SnifferInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasicNetworkInfo$Type extends MessageType<BasicNetworkInfo> {
    constructor() {
        super("proto.BasicNetworkInfo", [
            { no: 1, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BasicNetworkInfo>): BasicNetworkInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ssid = "";
        message.bssid = "";
        if (value !== undefined)
            reflectionMergePartial<BasicNetworkInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasicNetworkInfo): BasicNetworkInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ssid */ 1:
                    message.ssid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasicNetworkInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ssid = 1; */
        if (message.ssid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ssid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.BasicNetworkInfo
 */
export const BasicNetworkInfo = new BasicNetworkInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APListResponse$Type extends MessageType<APListResponse> {
    constructor() {
        super("proto.APListResponse", [
            { no: 1, name: "nets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BasicNetworkInfo }
        ]);
    }
    create(value?: PartialMessage<APListResponse>): APListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nets = [];
        if (value !== undefined)
            reflectionMergePartial<APListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APListResponse): APListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.BasicNetworkInfo nets */ 1:
                    message.nets.push(BasicNetworkInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.BasicNetworkInfo nets = 1; */
        for (let i = 0; i < message.nets.length; i++)
            BasicNetworkInfo.internalBinaryWrite(message.nets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APListResponse
 */
export const APListResponse = new APListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APGetRequest$Type extends MessageType<APGetRequest> {
    constructor() {
        super("proto.APGetRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APGetRequest>): APGetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.bssid = "";
        if (value !== undefined)
            reflectionMergePartial<APGetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APGetRequest): APGetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APGetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APGetRequest
 */
export const APGetRequest = new APGetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APGetResponse$Type extends MessageType<APGetResponse> {
    constructor() {
        super("proto.APGetResponse", [
            { no: 1, name: "ap", kind: "message", T: () => AccessPointInfo }
        ]);
    }
    create(value?: PartialMessage<APGetResponse>): APGetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<APGetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APGetResponse): APGetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.AccessPointInfo ap */ 1:
                    message.ap = AccessPointInfo.internalBinaryRead(reader, reader.uint32(), options, message.ap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APGetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.AccessPointInfo ap = 1; */
        if (message.ap)
            AccessPointInfo.internalBinaryWrite(message.ap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APGetResponse
 */
export const APGetResponse = new APGetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APProvidePasswordRequest$Type extends MessageType<APProvidePasswordRequest> {
    constructor() {
        super("proto.APProvidePasswordRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APProvidePasswordRequest>): APProvidePasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.bssid = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<APProvidePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APProvidePasswordRequest): APProvidePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APProvidePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APProvidePasswordRequest
 */
export const APProvidePasswordRequest = new APProvidePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APProvidePasswordResponse$Type extends MessageType<APProvidePasswordResponse> {
    constructor() {
        super("proto.APProvidePasswordResponse", [
            { no: 1, name: "state", kind: "enum", T: () => ["proto.APProvidePasswordResponse.DecryptionState", APProvidePasswordResponse_DecryptionState] }
        ]);
    }
    create(value?: PartialMessage<APProvidePasswordResponse>): APProvidePasswordResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<APProvidePasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APProvidePasswordResponse): APProvidePasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.APProvidePasswordResponse.DecryptionState state */ 1:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APProvidePasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.APProvidePasswordResponse.DecryptionState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APProvidePasswordResponse
 */
export const APProvidePasswordResponse = new APProvidePasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APGetDecryptedStreamRequest$Type extends MessageType<APGetDecryptedStreamRequest> {
    constructor() {
        super("proto.APGetDecryptedStreamRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "include_payload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<APGetDecryptedStreamRequest>): APGetDecryptedStreamRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.bssid = "";
        message.includePayload = false;
        if (value !== undefined)
            reflectionMergePartial<APGetDecryptedStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APGetDecryptedStreamRequest): APGetDecryptedStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                case /* bool include_payload */ 3:
                    message.includePayload = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APGetDecryptedStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        /* bool include_payload = 3; */
        if (message.includePayload !== false)
            writer.tag(3, WireType.Varint).bool(message.includePayload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APGetDecryptedStreamRequest
 */
export const APGetDecryptedStreamRequest = new APGetDecryptedStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APDeauthRequest$Type extends MessageType<APDeauthRequest> {
    constructor() {
        super("proto.APDeauthRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APDeauthRequest>): APDeauthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.bssid = "";
        if (value !== undefined)
            reflectionMergePartial<APDeauthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APDeauthRequest): APDeauthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APDeauthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APDeauthRequest
 */
export const APDeauthRequest = new APDeauthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APDeauthClientRequest$Type extends MessageType<APDeauthClientRequest> {
    constructor() {
        super("proto.APDeauthClientRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APDeauthClientRequest>): APDeauthClientRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.bssid = "";
        message.clientAddr = "";
        if (value !== undefined)
            reflectionMergePartial<APDeauthClientRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APDeauthClientRequest): APDeauthClientRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                case /* string client_addr */ 3:
                    message.clientAddr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APDeauthClientRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        /* string client_addr = 3; */
        if (message.clientAddr !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.clientAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APDeauthClientRequest
 */
export const APDeauthClientRequest = new APDeauthClientRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APGetHashRequest$Type extends MessageType<APGetHashRequest> {
    constructor() {
        super("proto.APGetHashRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_addr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APGetHashRequest>): APGetHashRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.bssid = "";
        message.clientAddr = "";
        if (value !== undefined)
            reflectionMergePartial<APGetHashRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APGetHashRequest): APGetHashRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                case /* string client_addr */ 3:
                    message.clientAddr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APGetHashRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        /* string client_addr = 3; */
        if (message.clientAddr !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.clientAddr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APGetHashRequest
 */
export const APGetHashRequest = new APGetHashRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APGetHashResponse$Type extends MessageType<APGetHashResponse> {
    constructor() {
        super("proto.APGetHashResponse", [
            { no: 1, name: "hc22000", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APGetHashResponse>): APGetHashResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hc22000 = "";
        if (value !== undefined)
            reflectionMergePartial<APGetHashResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APGetHashResponse): APGetHashResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hc22000 */ 1:
                    message.hc22000 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APGetHashResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hc22000 = 1; */
        if (message.hc22000 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hc22000);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APGetHashResponse
 */
export const APGetHashResponse = new APGetHashResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APIgnoreRequest$Type extends MessageType<APIgnoreRequest> {
    constructor() {
        super("proto.APIgnoreRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "use_ssid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APIgnoreRequest>): APIgnoreRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.useSsid = false;
        message.bssid = "";
        message.ssid = "";
        if (value !== undefined)
            reflectionMergePartial<APIgnoreRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APIgnoreRequest): APIgnoreRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* bool use_ssid */ 2:
                    message.useSsid = reader.bool();
                    break;
                case /* string bssid */ 3:
                    message.bssid = reader.string();
                    break;
                case /* string ssid */ 4:
                    message.ssid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APIgnoreRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* bool use_ssid = 2; */
        if (message.useSsid !== false)
            writer.tag(2, WireType.Varint).bool(message.useSsid);
        /* string bssid = 3; */
        if (message.bssid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bssid);
        /* string ssid = 4; */
        if (message.ssid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ssid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APIgnoreRequest
 */
export const APIgnoreRequest = new APIgnoreRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APCreateRecordingRequest$Type extends MessageType<APCreateRecordingRequest> {
    constructor() {
        super("proto.APCreateRecordingRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "raw", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<APCreateRecordingRequest>): APCreateRecordingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.name = "";
        message.bssid = "";
        message.raw = false;
        if (value !== undefined)
            reflectionMergePartial<APCreateRecordingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APCreateRecordingRequest): APCreateRecordingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string bssid */ 3:
                    message.bssid = reader.string();
                    break;
                case /* bool raw */ 4:
                    message.raw = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APCreateRecordingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string bssid = 3; */
        if (message.bssid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bssid);
        /* bool raw = 4; */
        if (message.raw !== false)
            writer.tag(4, WireType.Varint).bool(message.raw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APCreateRecordingRequest
 */
export const APCreateRecordingRequest = new APCreateRecordingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APCreateRecordingResponse$Type extends MessageType<APCreateRecordingResponse> {
    constructor() {
        super("proto.APCreateRecordingResponse", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<APCreateRecordingResponse>): APCreateRecordingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.packetCount = 0;
        if (value !== undefined)
            reflectionMergePartial<APCreateRecordingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APCreateRecordingResponse): APCreateRecordingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* uint32 packet_count */ 2:
                    message.packetCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APCreateRecordingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* uint32 packet_count = 2; */
        if (message.packetCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.packetCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.APCreateRecordingResponse
 */
export const APCreateRecordingResponse = new APCreateRecordingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusStartRequest$Type extends MessageType<FocusStartRequest> {
    constructor() {
        super("proto.FocusStartRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FocusStartRequest>): FocusStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.bssid = "";
        if (value !== undefined)
            reflectionMergePartial<FocusStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusStartRequest): FocusStartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string bssid */ 2:
                    message.bssid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string bssid = 2; */
        if (message.bssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bssid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.FocusStartRequest
 */
export const FocusStartRequest = new FocusStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusStartResponse$Type extends MessageType<FocusStartResponse> {
    constructor() {
        super("proto.FocusStartResponse", [
            { no: 1, name: "channel", kind: "message", T: () => ChannelInfo }
        ]);
    }
    create(value?: PartialMessage<FocusStartResponse>): FocusStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusStartResponse): FocusStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.ChannelInfo channel */ 1:
                    message.channel = ChannelInfo.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.ChannelInfo channel = 1; */
        if (message.channel)
            ChannelInfo.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.FocusStartResponse
 */
export const FocusStartResponse = new FocusStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusGetActiveResponse$Type extends MessageType<FocusGetActiveResponse> {
    constructor() {
        super("proto.FocusGetActiveResponse", [
            { no: 1, name: "bssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ssid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "channel", kind: "message", T: () => ChannelInfo }
        ]);
    }
    create(value?: PartialMessage<FocusGetActiveResponse>): FocusGetActiveResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bssid = "";
        message.ssid = "";
        if (value !== undefined)
            reflectionMergePartial<FocusGetActiveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusGetActiveResponse): FocusGetActiveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bssid */ 1:
                    message.bssid = reader.string();
                    break;
                case /* string ssid */ 2:
                    message.ssid = reader.string();
                    break;
                case /* proto.ChannelInfo channel */ 3:
                    message.channel = ChannelInfo.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusGetActiveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bssid = 1; */
        if (message.bssid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bssid);
        /* string ssid = 2; */
        if (message.ssid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ssid);
        /* proto.ChannelInfo channel = 3; */
        if (message.channel)
            ChannelInfo.internalBinaryWrite(message.channel, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.FocusGetActiveResponse
 */
export const FocusGetActiveResponse = new FocusGetActiveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingCreateRequest$Type extends MessageType<RecordingCreateRequest> {
    constructor() {
        super("proto.RecordingCreateRequest", [
            { no: 1, name: "sniffer_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "raw", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RecordingCreateRequest>): RecordingCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.snifferUuid = "";
        message.name = "";
        message.raw = false;
        if (value !== undefined)
            reflectionMergePartial<RecordingCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingCreateRequest): RecordingCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sniffer_uuid */ 1:
                    message.snifferUuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool raw */ 3:
                    message.raw = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sniffer_uuid = 1; */
        if (message.snifferUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snifferUuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool raw = 3; */
        if (message.raw !== false)
            writer.tag(3, WireType.Varint).bool(message.raw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.RecordingCreateRequest
 */
export const RecordingCreateRequest = new RecordingCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingCreateResponse$Type extends MessageType<RecordingCreateResponse> {
    constructor() {
        super("proto.RecordingCreateResponse", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "packet_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RecordingCreateResponse>): RecordingCreateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.packetCount = 0;
        if (value !== undefined)
            reflectionMergePartial<RecordingCreateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingCreateResponse): RecordingCreateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* uint32 packet_count */ 2:
                    message.packetCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingCreateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* uint32 packet_count = 2; */
        if (message.packetCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.packetCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.RecordingCreateResponse
 */
export const RecordingCreateResponse = new RecordingCreateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingListRequest$Type extends MessageType<RecordingListRequest> {
    constructor() {
        super("proto.RecordingListRequest", [
            { no: 1, name: "allowed_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["proto.DataLinkType", DataLinkType] }
        ]);
    }
    create(value?: PartialMessage<RecordingListRequest>): RecordingListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowedTypes = [];
        if (value !== undefined)
            reflectionMergePartial<RecordingListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingListRequest): RecordingListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.DataLinkType allowed_types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.allowedTypes.push(reader.int32());
                    else
                        message.allowedTypes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.DataLinkType allowed_types = 1; */
        if (message.allowedTypes.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.allowedTypes.length; i++)
                writer.int32(message.allowedTypes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.RecordingListRequest
 */
export const RecordingListRequest = new RecordingListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingListResponse$Type extends MessageType<RecordingListResponse> {
    constructor() {
        super("proto.RecordingListResponse", [
            { no: 1, name: "recordings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Recording }
        ]);
    }
    create(value?: PartialMessage<RecordingListResponse>): RecordingListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recordings = [];
        if (value !== undefined)
            reflectionMergePartial<RecordingListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingListResponse): RecordingListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.Recording recordings */ 1:
                    message.recordings.push(Recording.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.Recording recordings = 1; */
        for (let i = 0; i < message.recordings.length; i++)
            Recording.internalBinaryWrite(message.recordings[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.RecordingListResponse
 */
export const RecordingListResponse = new RecordingListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingLoadDecryptedRequest$Type extends MessageType<RecordingLoadDecryptedRequest> {
    constructor() {
        super("proto.RecordingLoadDecryptedRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_payload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RecordingLoadDecryptedRequest>): RecordingLoadDecryptedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.includePayload = false;
        if (value !== undefined)
            reflectionMergePartial<RecordingLoadDecryptedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingLoadDecryptedRequest): RecordingLoadDecryptedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* bool include_payload */ 2:
                    message.includePayload = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingLoadDecryptedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* bool include_payload = 2; */
        if (message.includePayload !== false)
            writer.tag(2, WireType.Varint).bool(message.includePayload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.RecordingLoadDecryptedRequest
 */
export const RecordingLoadDecryptedRequest = new RecordingLoadDecryptedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetworkInterfaceListResponse$Type extends MessageType<NetworkInterfaceListResponse> {
    constructor() {
        super("proto.NetworkInterfaceListResponse", [
            { no: 1, name: "ifaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NetworkInterfaceListResponse>): NetworkInterfaceListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ifaces = [];
        if (value !== undefined)
            reflectionMergePartial<NetworkInterfaceListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkInterfaceListResponse): NetworkInterfaceListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ifaces */ 1:
                    message.ifaces.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetworkInterfaceListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ifaces = 1; */
        for (let i = 0; i < message.ifaces.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.ifaces[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.NetworkInterfaceListResponse
 */
export const NetworkInterfaceListResponse = new NetworkInterfaceListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogEntry$Type extends MessageType<LogEntry> {
    constructor() {
        super("proto.LogEntry", [
            { no: 1, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 2, name: "level", kind: "enum", T: () => ["proto.LogEntry.LogLevel", LogEntry_LogLevel] },
            { no: 3, name: "scope", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogEntry>): LogEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.level = 0;
        message.scope = "";
        message.payload = "";
        if (value !== undefined)
            reflectionMergePartial<LogEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogEntry): LogEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp timestamp */ 1:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* proto.LogEntry.LogLevel level */ 2:
                    message.level = reader.int32();
                    break;
                case /* string scope */ 3:
                    message.scope = reader.string();
                    break;
                case /* string payload */ 4:
                    message.payload = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp timestamp = 1; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* proto.LogEntry.LogLevel level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* string scope = 3; */
        if (message.scope !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.scope);
        /* string payload = 4; */
        if (message.payload !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.LogEntry
 */
export const LogEntry = new LogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatteryGetLevelResponse$Type extends MessageType<BatteryGetLevelResponse> {
    constructor() {
        super("proto.BatteryGetLevelResponse", [
            { no: 1, name: "percentage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<BatteryGetLevelResponse>): BatteryGetLevelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.percentage = 0;
        if (value !== undefined)
            reflectionMergePartial<BatteryGetLevelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatteryGetLevelResponse): BatteryGetLevelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float percentage */ 1:
                    message.percentage = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatteryGetLevelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float percentage = 1; */
        if (message.percentage !== 0)
            writer.tag(1, WireType.Bit32).float(message.percentage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.BatteryGetLevelResponse
 */
export const BatteryGetLevelResponse = new BatteryGetLevelResponse$Type();
/**
 * @generated ServiceType for protobuf service proto.Sniffer
 */
export const Sniffer = new ServiceType("proto.Sniffer", [
    { name: "SnifferCreate", options: {}, I: SnifferCreateRequest, O: SnifferID },
    { name: "SnifferDestroy", options: {}, I: SnifferID, O: Empty },
    { name: "SnifferList", options: {}, I: Empty, O: SnifferListResponse },
    { name: "AccessPointList", options: {}, I: SnifferID, O: APListResponse },
    { name: "AccessPointGet", options: {}, I: APGetRequest, O: APGetResponse },
    { name: "AccessPointProvidePassword", options: {}, I: APProvidePasswordRequest, O: APProvidePasswordResponse },
    { name: "AccessPointGetDecryptedStream", serverStreaming: true, options: {}, I: APGetDecryptedStreamRequest, O: Packet },
    { name: "AccessPointDeauth", options: {}, I: APDeauthRequest, O: Empty },
    { name: "AccessPointDeauthClient", options: {}, I: APDeauthClientRequest, O: Empty },
    { name: "AccessPointGetHash", options: {}, I: APGetHashRequest, O: APGetHashResponse },
    { name: "AccessPointIgnore", options: {}, I: APIgnoreRequest, O: Empty },
    { name: "AccessPointListIgnored", options: {}, I: SnifferID, O: APListResponse },
    { name: "AccessPointCreateRecording", options: {}, I: APCreateRecordingRequest, O: APCreateRecordingResponse },
    { name: "FocusStart", options: {}, I: FocusStartRequest, O: FocusStartResponse },
    { name: "FocusGetActive", options: {}, I: SnifferID, O: FocusGetActiveResponse },
    { name: "FocusStop", options: {}, I: SnifferID, O: Empty },
    { name: "RecordingCreate", options: {}, I: RecordingCreateRequest, O: RecordingCreateResponse },
    { name: "RecordingList", options: {}, I: RecordingListRequest, O: RecordingListResponse },
    { name: "RecordingLoadDecrypted", serverStreaming: true, options: {}, I: RecordingLoadDecryptedRequest, O: Packet },
    { name: "NetworkInterfaceList", options: {}, I: Empty, O: NetworkInterfaceListResponse },
    { name: "LogGetStream", serverStreaming: true, options: {}, I: Empty, O: LogEntry },
    { name: "BatteryGetLevel", options: {}, I: Empty, O: BatteryGetLevelResponse }
]);
